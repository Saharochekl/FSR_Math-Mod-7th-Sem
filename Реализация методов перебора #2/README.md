# Перебор таблично-заданных функций: последовательный и с отсечением ветвей

## Что делает код

`lab_func.py` читает четыре MIDE-отчета (`*.txt` в текущей директории), извлекает столбец времени и числовые ряды, затем для каждого ряда считает минимум двумя способами:

1. **Последовательный перебор** по дискретным точкам (линейный проход, `seq_enum`).
2. **Перебор с отсечением “паразитических” ветвей** на основе **Липшицевой** нижней оценки (при известном/оцененном `L`) и очереди приоритетов (`bb_lipschitz_discrete`).

Результаты сводятся в `enumeration_summary.csv`.

Файлы, которые обрабатываются:
- `angle-func.txt`
- `angular-velocity-function.txt`
- `distance_txt.txt`
- `satellite-facility-dist.txt`

## Как парсятся входные данные

- Интерпретируется как текст с неопределенной кодировкой (`read_text_any_encoding`).
- Ищется строка заголовка по признаку столбца “Время”/“Time” или минимум по наличию `;` (`find_header_row`).
- Читается как `;`-разделенный CSV. Столбец времени приводится к секундам с начала, прочие столбцы — к числам.
- Данные сортируются по времени и фильтруются от `NaN`.

## Метод 1: последовательный перебор (`seq_enum`)
Для дискретного вектора `y` возвращается `(i*, y[i*])`, где `i* = argmin y`. Это эталон для сравнения.

- Сложность по числу оценок: `N`.
- Гарантированно находит минимум на сетке.

## Метод 2: перебор с отсечением на основе Липшица (`bb_lipschitz_discrete`)

### Идея
Для интервала `[x_i, x_j]` при Липшицевости с константой `L` справедлива нижняя оценка
```
f(x) ≥ max( y_i − L|x − x_i|,  y_j − L|x_j − x| )
```
Её минимум по `x` достигается в точке
```
x_c = (x_i + x_j + (y_j − y_i)/L)/2
```
а сама нижняя грань на интервале равна
```
r_ij = max( y_i − L(x_c − x_i),  y_j − L(x_j − x_c) ).
```
Мы держим на куче интервалы с приоритетом по `r_ij`. Выталкиваем интервал с минимальным `r_ij`, выбираем дискретную точку, ближайшую к `x_c`, оцениваем `f` и при необходимости добавляем в кучу левый и правый подинтервалы.

### Оценка `L` (константы Липшица)
В `estimate_L` берется `dx = Δx`, `dy = |Δy|`, затем `slopes = dy/dx`, и возвращается
```
L = 1.01 * max( q95(slopes), max(slopes) )
```
что делает оценку устойчивой к шуму, но не занижает верхнюю границу.

### Остановка
Когда минимальный `r_ij` в куче больше либо равен текущему лучшему значению `f_best`, более выгодных интервалов не осталось, можно прекращать.

- Сложность: `O(K log M)`, где `K` — число реально оцененных точек (обычно `K << N`), `M` — число активных интервалов.

## Что в таблице `enumeration_summary.csv`

- `file`, `column`: источник ряда
- `N_total`: число допустимых точек
- `L_est`: оцененная константа Липшица
- `seq_argmin_index`, `seq_argmin_time_s`, `seq_min_value`
- `bb_argmin_index`, `bb_argmin_time_s`, `bb_min_value`
- `evals_used_bb`: сколько точек реально “посмотрел” метод с отсечением
- `eval_savings_pct = 100 * (1 − evals_used_bb/N_total)`
- `exact_match`: флаг, совпали ли индекс и значение с последовательным перебором

## Запуск

```
python3 lab_func.py
```

Файл `enumeration_summary.csv` появится в текущей директории.

## Замечание о корректности и настройке `L`

Метод с отсечением корректен только если `L` **не занижена**. При слишком малой `L` нижние оценки `r_ij` могут оказаться **слишком высокими**, что приводит к преждевременной остановке и, как следствие, к **невыбору** истинного минимума на дискретной сетке.

В исходной версии занижение происходило из-за множителя `0.9 * max(slopes)`. Мы заменили его на безопасный вариант `1.01 * max(q95, max)`.

Если данные особенно “крутые” локально, можно усилить `L` дополнительным коэффициентом (например, `×3`) или реализовать адаптивную схему: при несовпадении минимума с эталонным (`seq`) умножать `L` на 2 и повторять перебор, пока `bb_min_value ≤ seq_min_value` или исчерпан лимит оценок.

## Внутренние функции

- `read_text_any_encoding(path)` — грубая, но практичная загрузка текста.
- `find_header_row(text)` — поиск строки с заголовком.
- `read_mide_table(path)` — парсинг MIDE-совместимого `;`‑CSV, перевод времени в секунды.
- `estimate_L(x, y)` — оценка константы Липшица по конечным разностям.
- `seq_enum(x, y)` — последовательный перебор.
- `interval_lb(...)` — нижняя оценка `r_ij`, точка `x_c`.
- `nearest_interior_index(...)` — дискретная точка, ближайшая к `x_c`.
- `bb_lipschitz_discrete(x, y, L, tol=0.0)` — собственно перебор с отсечением.
- `process_file(path)` — запуск двух методов для всех столбцов файла, агрегация результата.
- `main()` — проход по `DATA_FILES` и выгрузка отчета.

